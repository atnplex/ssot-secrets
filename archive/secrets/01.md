To make this your "Universal Standard" for the homelab, we need to move away from embedding scripts into individual Dockerfiles (which is hard to maintain) and move toward a **"Mountable Toolbox"** strategy.

This approach creates a single directory on your Unraid host containing the tools (`age`, `jq`, `bws`) and a master script. You then mount this directory into *any* container (Plex, Cloudflare, *Arr apps) to give it instant secret management capabilities without rebuilding images.

### The Architecture: "The Side-Load Toolbox"

Instead of installing tools inside every container, we provide them via a volume mount.

1. **Host Directory (`/mnt/user/appdata/secrets-toolbox/`)**: Contains static binaries of `age`, `jq`, and `bws`, plus your master script and encryption key.
2. **Container Mount**: This folder is mapped to `/secrets` inside every container.
3. **Universal Entrypoint**: You override the container's entrypoint to run the script from the mounted folder first.

---

### Step 1: Prepare the Toolbox (One-Time Setup)

On your Unraid host, create the directory and download **static** binaries. Using static binaries ensures they work on any Linux distro (Alpine, Debian, Ubuntu) inside your containers.

```bash
# 1. Create directory
mkdir -p /mnt/user/appdata/secrets-toolbox/bin

# 2. Download Static Binaries (commands for 64-bit Linux)
cd /mnt/user/appdata/secrets-toolbox/bin

# bws (Bitwarden Secrets Manager)
wget "https://github.com/bitwarden/sdk/releases/download/bws-v0.5.0/bws-x86_64-unknown-linux-gnu.zip"
unzip bws-*.zip && rm bws-*.zip && chmod +x bws

# age (Encryption)
wget "https://github.com/FiloSottile/age/releases/download/v1.1.1/age-v1.1.1-linux-amd64.tar.gz"
tar -xzf age-*.tar.gz --strip-components=1 age/age && rm age-*.tar.gz && chmod +x age

# jq (JSON Processor)
wget -O jq "https://github.com/jqlang/jq/releases/download/jq-1.7.1/jq-linux-amd64"
chmod +x jq

# 3. Generate your Master Key
./age -g -o ../master.key

```

### Step 2: The Universal Script (`init.sh`)

Create `/mnt/user/appdata/secrets-toolbox/init.sh`. This script is POSIX-compliant (works in `sh` and `bash`) so it runs on minimal images like Alpine.

```bash
#!/bin/sh

# === Configuration ===
TOOLBOX="/secrets"
BIN="$TOOLBOX/bin"
CACHE_FILE="$TOOLBOX/cache.age"
KEY_FILE="$TOOLBOX/master.key"

# Add our static binaries to PATH for this session
export PATH="$BIN:$PATH"

# User inputs (Passed via Docker ENV)
# BWS_ACCESS_TOKEN is required for online sync
# SECRET_KEY_NAME is the JSON key to look for (e.g., "CLOUDFLARED" or "PLEX")

log() { echo "[SECRETS-INIT] $1"; }

get_secrets_from_cache() {
    if [ -f "$CACHE_FILE" ]; then
        # Decrypt and verify JSON validity (-e to exit on fail)
        DECRYPTED=$(age -d -i "$KEY_FILE" "$CACHE_FILE" 2>/dev/null)
        if [ $? -eq 0 ] && [ -n "$DECRYPTED" ]; then
            echo "$DECRYPTED"
            return 0
        fi
    fi
    return 1
}

fetch_secrets_online() {
    log "Connecting to Bitwarden (SSOT)..."
    # Fetch specific secret ID that holds your big JSON blob
    # You might pass the BWS_SECRET_ID as an env var too
    PAYLOAD=$(bws secret get "$BWS_SECRET_ID" | jq -r '.value')
    
    if [ -n "$PAYLOAD" ]; then
        log "Updating local encrypted cache..."
        # Atomic write
        RECIPIENT=$(grep "public key" "$KEY_FILE" | awk '{print $4}')
        echo "$PAYLOAD" | age -r "$RECIPIENT" > "${CACHE_FILE}.tmp" && mv "${CACHE_FILE}.tmp" "$CACHE_FILE"
        echo "$PAYLOAD"
    else
        log "CRITICAL: Could not fetch secrets from Bitwarden."
        return 1
    fi
}

# 1. Logic Loop
# Try Cache -> If Fail, Go Online -> If Fail, Exit
SECRETS=$(get_secrets_from_cache)
if [ -z "$SECRETS" ]; then
    log "Cache miss or invalid. Going online."
    SECRETS=$(fetch_secrets_online)
    if [ -z "$SECRETS" ]; then exit 1; fi
fi

# 2. Extract Specific Secrets for THIS Service
# We look for a JSON object matching the SECRET_KEY_NAME (e.g., "CLOUDFLARED")
# and export all keys inside it as Environment Variables.
if [ -n "$SECRET_KEY_NAME" ]; then
    log "Injecting secrets for: $SECRET_KEY_NAME"
    
    # Create a clean export string
    VARS=$(echo "$SECRETS" | jq -r --arg key "$SECRET_KEY_NAME" '.[$key] | to_entries | .[] | "export " + .key + "=\"" + .value + "\""')
    
    if [ -z "$VARS" ] || [ "$VARS" = "null" ]; then
        log "No secrets found for $SECRET_KEY_NAME"
    else
        # Eval the exports into current shell
        eval "$VARS"
    fi
fi

# 3. Execution & Self-Healing
# We execute the command. If it crashes (exit code != 0), we assume secrets might be stale.
log "Starting Application..."

# Run the passed command in the background? No, we need to monitor it.
"$@"
EXIT_CODE=$?

if [ $EXIT_CODE -ne 0 ]; then
    log "Application crashed (Code: $EXIT_CODE). Checking for stale secrets..."
    
    # Force Refresh
    SECRETS=$(fetch_secrets_online)
    
    # Re-Inject
    VARS=$(echo "$SECRETS" | jq -r --arg key "$SECRET_KEY_NAME" '.[$key] | to_entries | .[] | "export " + .key + "=\"" + .value + "\""')
    eval "$VARS"
    
    log "Restarting Application with fresh secrets..."
    exec "$@"
else
    exit 0
fi

```

### Step 3: Deployment (How to use it universally)

You now have a portable system. Here is how you apply it to **any** service.

#### Bitwarden Setup

Store all your homelab secrets in **one** JSON note in Bitwarden to minimize API calls.

* **Secret Name:** `HOMELAB_MASTER`
* **Value (JSON):**
```json
{
  "CLOUDFLARED": {
    "TUNNEL_TOKEN": "eyJh..."
  },
  "PLEX": {
    "PLEX_CLAIM": "claim-xxx"
  },
  "MARIADB": {
    "MYSQL_ROOT_PASSWORD": "supersecretpassword"
  }
}

```



#### Docker Compose / Unraid Usage

You only need to add 3 things to any container definition:

1. **Volume:** Map the toolbox.
2. **Env:** Tell the script which key to load (`SECRET_KEY_NAME`) and the ID of the master secret (`BWS_SECRET_ID`).
3. **Entrypoint:** Prepend the script.

**Example: Cloudflare Tunnel**

```yaml
services:
  cloudflared:
    image: cloudflare/cloudflared:latest
    container_name: cloudflared
    environment:
      - BWS_ACCESS_TOKEN=<YOUR_TOKEN>
      - BWS_SECRET_ID=<ID_OF_HOMELAB_MASTER_NOTE>
      - SECRET_KEY_NAME=CLOUDFLARED  # Matches the JSON key in Bitwarden
    volumes:
      # Map the toolbox (Read Only for safety, unless you want it to update the cache)
      # If you want the script to UPDATE the cache, it must be Read/Write
      - /mnt/user/appdata/secrets-toolbox:/secrets
    entrypoint: 
      - "/secrets/init.sh"     # <--- Our Wrapper
      - "tunnel"               # <--- Original Command Part 1
      - "run"                  # <--- Original Command Part 2

```

### Addressing LinuxServer.io Images (Plex, Sonarr, etc.)

Containers from LinuxServer.io use `s6-overlay` and don't like you overriding the `entrypoint`.

For these, you should **not** override the entrypoint. Instead, map the script to their custom init folder.

**For Plex/Sonarr/Radarr:**

1. Map `/mnt/user/appdata/secrets-toolbox/init.sh` to `/custom-cont-init.d/01-secrets`.
2. The `s6` init system will automatically source this script before the app starts.
3. *Note:* The "Self-Healing" restart loop won't work as easily here because `s6` manages the process, but the "Cache vs Online" logic will work perfectly during boot.

### Summary

1. **Toolbox:** `/mnt/user/appdata/secrets-toolbox` contains binaries + key + script.
2. **Secret Source:** One JSON blob in Bitwarden organized by service name.
3. **Automation:** The script auto-decrypts locally. If that fails or the app crashes, it auto-fetches from cloud.
4. **Security:** Keys are in memory (ENV), encrypted on disk (`.age`), and never hardcoded.

Would you like me to detail how to set up the **BWS Machine Account** permissions to ensure this token can *only* read that specific secret?


---

Here is a robust, idempotent setup script designed for your Unraid host.

### Universal Toolbox Setup Script

This script implements the **"Verify-Then-Commit"** pattern. It works in a temporary sandbox (`tmpfs`) and only touches your production directory if the downloaded binary executes successfully.

Save this as `setup_toolbox.sh` on your Unraid host and run it (`bash setup_toolbox.sh`).

```bash
#!/bin/bash
set -euo pipefail

# === Configuration ===
TOOLBOX_DIR="/mnt/user/appdata/secrets-toolbox"
BIN_DIR="${TOOLBOX_DIR}/bin"
KEY_FILE="${TOOLBOX_DIR}/master.key"

# Ensure directories exist
mkdir -p "$BIN_DIR"

# === The Generalized Installer Function ===
install_tool() {
    local name="$1"
    local url="$2"
    local binary_name="$3" # Name of the binary to look for or save as
    local test_arg="$4"    # Argument to test execution (e.g., --version)
    
    echo "------------------------------------------------"
    echo "[Starting] Installing $name..."

    # 1. Create secure temporary workspace
    local tmp_dir
    tmp_dir=$(mktemp -d -t "toolbox-${name}-XXXXXX")
    
    # Ensure cleanup happens even on failure
    trap 'rm -rf "$tmp_dir"' EXIT

    echo "   [1/4] Downloading to sandbox ($tmp_dir)..."
    local download_file="$tmp_dir/downloaded_artifact"
    
    # Download with curl, failing silently (-s) but outputting errors (-S) and failing on HTTP error (-f)
    if ! curl -fL "$url" -o "$download_file"; then
        echo "   [Error] Download failed for $url"
        return 1
    fi

    echo "   [2/4] Extracting/Processing..."
    local candidate_bin="$tmp_dir/$binary_name"

    # Detect file type and extract accordingly
    if [[ "$url" == *.zip ]]; then
        if ! unzip -q -o "$download_file" -d "$tmp_dir"; then
            echo "   [Error] Unzip failed."
            return 1
        fi
        # Zip might extract to root or subfolder, find the binary
        found_bin=$(find "$tmp_dir" -type f -name "$binary_name" | head -n 1)
        if [[ -z "$found_bin" ]]; then
            echo "   [Error] Binary '$binary_name' not found in zip archive."
            return 1
        fi
        mv "$found_bin" "$candidate_bin"

    elif [[ "$url" == *.tar.gz || "$url" == *.tgz ]]; then
        if ! tar -xzf "$download_file" -C "$tmp_dir"; then
            echo "   [Error] Tar extraction failed."
            return 1
        fi
        # Tar usually has structure, verify where binary is
        found_bin=$(find "$tmp_dir" -type f -name "$binary_name" | head -n 1)
        if [[ -z "$found_bin" ]]; then
             echo "   [Error] Binary '$binary_name' not found in tar archive."
             return 1
        fi
        mv "$found_bin" "$candidate_bin"

    else
        # Assume raw binary if not zip/tar
        mv "$download_file" "$candidate_bin"
    fi

    # Make executable
    chmod +x "$candidate_bin"

    echo "   [3/4] Verifying binary execution..."
    if ! "$candidate_bin" $test_arg > /dev/null 2>&1; then
        echo "   [Error] Verification failed. The binary did not run successfully."
        return 1
    fi

    echo "   [4/4] Verification Passed. Installing to $BIN_DIR..."
    mv -f "$candidate_bin" "${BIN_DIR}/${name}"

    echo "[Success] $name installed successfully."
    
    # Clear trap for this function scope so we don't delete the next function's temp
    trap - EXIT
    rm -rf "$tmp_dir"
}

# === Tool Definitions ===

# 1. Bitwarden Secrets Manager (BWS)
# Type: ZIP
install_tool "bws" \
    "https://github.com/bitwarden/sdk/releases/download/bws-v0.5.0/bws-x86_64-unknown-linux-gnu.zip" \
    "bws" \
    "--version"

# 2. Age (Encryption)
# Type: TAR.GZ
install_tool "age" \
    "https://github.com/FiloSottile/age/releases/download/v1.1.1/age-v1.1.1-linux-amd64.tar.gz" \
    "age" \
    "--version"

# 3. JQ (JSON Processor)
# Type: RAW BINARY
install_tool "jq" \
    "https://github.com/jqlang/jq/releases/download/jq-1.7.1/jq-linux-amd64" \
    "jq" \
    "--version"


# === Master Key Generation (Idempotent) ===

echo "------------------------------------------------"
echo "[Checking] Encryption Keys..."

if [[ -f "$KEY_FILE" ]]; then
    echo "   [Skip] Master key already exists at $KEY_FILE"
    
    # Validation: Check if the key file actually contains a key
    if grep -q "public key" "$KEY_FILE"; then
        echo "   [OK] Key file appears valid."
    else
        echo "   [Warn] Key file exists but might be empty/invalid."
    fi
else
    echo "   [Action] Generating new Master Key..."
    "${BIN_DIR}/age" -g -o "$KEY_FILE"
    echo "   [Success] Key generated at $KEY_FILE"
fi

echo "------------------------------------------------"
echo "Toolbox Setup Complete."

```

### Key Features of This Implementation

1. **Atomic Installation:** It never moves a broken file to your `bin` folder. It downloads to a temp folder, extracts, makes it executable, and **runs it**. Only if it runs successfully does it move it to the final location.
2. **Format Agnostic:** The script automatically detects `.zip`, `.tar.gz`, or raw binaries (like `jq`) and handles the extraction logic appropriately.
3. **Idempotent:**
* **Binaries:** It effectively "re-installs" every time you run it, which ensures you always have the version specified in the script. If the file is already there, it gets overwritten by the fresh, verified download.
* **Keys:** It explicitly checks `if [[ -f "$KEY_FILE" ]]` before generating a key, so you never accidentally overwrite your encryption identity.


4. **Self-Contained Cleanup:** It uses `trap` to ensure that even if the script crashes halfway through a download, the temporary folders in `/tmp` are deleted.
